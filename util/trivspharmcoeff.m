% Copyright 2014 Lukas Lang
%
% This file is part of OFISH.
%
%    OFISH is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    OFISH is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with OFISH.  If not, see <http://www.gnu.org/licenses/>.
function [Y1, Y2, DxY1, DyY1, DxY2, DyY2] = trivspharmcoeff(N, F, V, xi)
%TRIVSPHARMCOEFF Returns coefficients and first partial derivatives of 
%fully normalised vector spherical harmonics in the tangent basis created 
%by TRITANBASIS.
%
%   [Y1, Y2, DxY1, DyY1, DxY2, DyY2] = TRIVSPHARMCOEFF(N, F, V, xi) takes a
%   triangulation F, V of the unit sphere and returns the coefficients in 
%   terms of the tangent basis generated by tritanBasis of fully normalised
%   vector spherical harmonics Y_Nj of degree N > 0 and j=-N,...,N at 
%   barycentric coordinates xi. Moreover, the first partial derivatives of
%   the coefficients are returned.
%
%   Note that the size of each output is [m, 2*N + 1, 2, nq], where m is 
%   the number of faces F. xi must be of size [m, 2, nq], where nq is the
%   number of quadrature points on each triangle.
%
%   The third index of Yi corresponds to Dx and Dy of the triangular basis.

assert(isscalar(N));
assert(N > 0);
assert(size(F, 2) == 3);
assert(size(V, 2) == 3);
assert(size(xi, 1) == size(F, 1));
assert(size(xi, 2) == 2);

m = size(F, 1);
nq = size(xi, 3);

% Compute triangle areas.
a = triangArea(F, V);

% Project scalar spherical harmonics at nodal points.
Vn = normalise(trinodalpts2(F, V));
Ynj = zeros(m, 2 * N + 1, size(Vn, 3));
for k=1:size(Vn, 3)
    Ynj(:, :, k) = spharm(N, Vn(:, :, k));
end

% Compute triangulated surface properties.
[Dx, Dy] = tritanBasis(F, V);

% Compute metric properties.
[~, ~, ginv] = metricprops(Dx, Dy);
ginv11 = ginv(:, 1, 1);
ginv12 = ginv(:, 1, 2);
ginv21 = ginv(:, 2, 1);
ginv22 = ginv(:, 2, 2);

% Compute vector spherical harmonics.
Y1 = zeros(m, 2*N + 1, 2, nq);
Y2 = zeros(m, 2*N + 1, 2, nq);
DxY1 = zeros(m, 2*N + 1, 2, nq);
DyY1 = zeros(m, 2*N + 1, 2, nq);
DxY2 = zeros(m, 2*N + 1, 2, nq);
DyY2 = zeros(m, 2*N + 1, 2, nq);
for q=1:nq
    % Compute partial derivatives of polynomials at xi.
    [DxA, DyA, Q] = tripoly2deriv(xi(:, :, q));
    % Compute second partial derivatives of polynomials at xi.
    [DxDxA, DyDxA, DxDyA, DyDyA, ~] = tripoly2deriv2(xi(:, :, q));
    for k=1:2*N+1
        f = squeeze(Ynj(:, k, :));    
        % Compute partial derivative of interpolation.
        Dxf = dot(f, (DxA * Q)', 2);
        Dyf = dot(f, (DyA * Q)', 2);

        % Compute coefficients.
        Y1(:, k, :, q) = [ginv11 .* Dxf + ginv21 .* Dyf, ginv12 .* Dxf + ginv22 .* Dyf];
        Y2(:, k, :, q) = [bsxfun(@rdivide, Dyf, 2 * a), bsxfun(@rdivide, -Dxf, 2 * a)];
        
        % Compute second partial derivatives of interpolation.
        DxDxf = dot(f, (DxDxA * Q)', 2);
        DyDxf = dot(f, (DyDxA * Q)', 2);
        DxDyf = dot(f, (DxDyA * Q)', 2);
        DyDyf = dot(f, (DyDyA * Q)', 2);
        
        % Compute derivatives.
        DxY1(:, k, :, q) = [ginv11 .* DxDxf + ginv21 .* DxDyf, ginv12 .* DxDxf + ginv22 .* DxDyf];
        DyY1(:, k, :, q) = [ginv11 .* DyDxf + ginv21 .* DyDyf, ginv12 .* DyDxf + ginv22 .* DyDyf];
        
        DxY2(:, k, :, q) = [bsxfun(@rdivide, DxDyf, 2 * a), bsxfun(@rdivide, -DxDxf, 2 * a)];
        DyY2(:, k, :, q) = [bsxfun(@rdivide, DyDyf, 2 * a), bsxfun(@rdivide, -DyDxf, 2 * a)];
    end
end

% Normalise.
Y1 = Y1 ./ sqrt(N*(N+1));
Y2 = Y2 ./ sqrt(N*(N+1));
DxY1 = DxY1 ./ sqrt(N*(N+1));
DyY1 = DyY1 ./ sqrt(N*(N+1));
DxY2 = DxY2 ./ sqrt(N*(N+1));
DyY2 = DyY2 ./ sqrt(N*(N+1));

end