% Copyright 2014 Lukas Lang
%
% This file is part of OFISH.
%
%    OFISH is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    OFISH is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with OFISH.  If not, see <http://www.gnu.org/licenses/>.
function [Z11, Z12, Z21, Z22] = surfcovderiv(G, g, A, Y, DY, xi)
%SURFCOVDERIV Takes a vector field on a sphere-like surface and computes 
%the covariant derivative of other given vector fields with respect to the 
%first. 
%
%   Z = SURFCOVDERIV(G, g, A, Y, DY, xi) takes a vector field specified by 
%   a transformation matrix A from the tangent basis at points xi, and a
%   matrix Y of scalar spherical harmonics evaluated at xi, its derivatives
%   DY and returns the coefficients Zij of the covariant derivative of 
%   vector spherical harmonics. In addition, Christoffel symbols G and 
%   metric g are needed.
%
%   Note that xi must be a matrix of size [m, 2, nq], where m is the number
%   of triangular faces and nq is the number of quadrature points.
%
%   A must be of size [2, 2, m, 6] and is interpolated quadratically.
%
%   Y is of size [m, dim, nq], DY of size [m, 2, dim, 2, nq] generated by
%   trispharmncoeff.
%
%   dim is the dimension of both tangential type vspharm!
%
%   Zij is of size [m, dim, nq] and denotes D_i u^j, which is the
%   derivation with respect to e_i (the ONB given by matrix A).

m = size(A, 3);
assert(size(A, 1) == 2);
assert(size(A, 2) == 2);
assert(size(A, 4) == 6);

nq = size(xi, 3);
assert(size(xi, 1) == m);
assert(size(xi, 2) == 2);

dim = size(Y, 2);
assert(size(Y, 1) == m);
assert(size(Y, 3) == 2);
assert(size(Y, 4) == nq);

assert(size(DY, 1) == m);
assert(size(DY, 2) == 2);
assert(size(DY, 3) == dim);
assert(size(DY, 4) == 2);
assert(size(DY, 5) == nq);

assert(size(G, 1) == m);
assert(size(G, 2) == 2);
assert(size(G, 3) == 2);
assert(size(G, 4) == 2);
assert(size(G, 5) == nq);

assert(size(g, 1) == m);
assert(size(g, 2) == 2);
assert(size(g, 3) == 2);
assert(size(g, 4) == nq);

% Compute interpolations and determinant of A.
Ai(:, 1, 1, :) = triinterp2(squeeze(A(1, 1, :, :)), xi);
Ai(:, 1, 2, :) = triinterp2(squeeze(A(1, 2, :, :)), xi);
Ai(:, 2, 1, :) = triinterp2(squeeze(A(2, 1, :, :)), xi);
Ai(:, 2, 2, :) = triinterp2(squeeze(A(2, 2, :, :)), xi);
detA = squeeze(Ai(:, 1, 1, :) .* Ai(:, 2, 2, :) - Ai(:, 1, 2, :) .* Ai(:, 2, 1, :));

Ainv(:, 1, 1, :) = squeeze(Ai(:, 2, 2, :)) ./ detA;
Ainv(:, 1, 2, :) = -squeeze(Ai(:, 2, 1, :)) ./ detA;
Ainv(:, 2, 1, :) = -squeeze(Ai(:, 1, 2, :)) ./ detA;
Ainv(:, 2, 2, :) = squeeze(Ai(:, 1, 1, :)) ./ detA;

% Compute derivatives of A.
DA = zeros(m, 2, 2, 2, nq);
for q=1:nq
    % Compute derivatives of polynomials at xi.
    [DxA, DyA, Q] = tripoly2deriv(xi(:, :, q));
    DxA = (DxA * Q)';
    DyA = (DyA * Q)';
    % Compute partial derivative of interpolation D_k Aij.
    DA(:, 1, 1, 1, q) = dot(squeeze(A(1, 1, :, :)), DxA, 2);
    DA(:, 2, 1, 1, q) = dot(squeeze(A(1, 1, :, :)), DyA, 2);
    DA(:, 1, 1, 2, q) = dot(squeeze(A(1, 2, :, :)), DxA, 2);
    DA(:, 2, 1, 2, q) = dot(squeeze(A(1, 2, :, :)), DyA, 2);
    DA(:, 1, 2, 1, q) = dot(squeeze(A(2, 1, :, :)), DxA, 2);
    DA(:, 2, 2, 1, q) = dot(squeeze(A(2, 1, :, :)), DyA, 2);
    DA(:, 1, 2, 2, q) = dot(squeeze(A(2, 2, :, :)), DxA, 2);
    DA(:, 2, 2, 2, q) = dot(squeeze(A(2, 2, :, :)), DyA, 2);
end

% Compute derivatives of detA.
DdetA = zeros(m, 2, nq);
for k=1:2
    DdetA(:, k, :) = squeeze(Ai(:, 1, 1, :)) .* squeeze(DA(:, k, 2, 2, :)) + squeeze(Ai(:, 2, 2, :)) .* squeeze(DA(:, k, 1, 1, :)) - squeeze(Ai(:, 1, 2, :)) .* squeeze(DA(:, k, 2, 1, :)) - squeeze(Ai(:, 2, 1, :)) .* squeeze(DA(:, k, 1, 2, :));
end

% Compute derivatives of Ainv.
DAinv = zeros(m, 2, 2, 2, nq);
for k=1:2
    DAinv(:, k, 1, 1, :) = (squeeze(DA(:, k, 2, 2, :)) .* detA - squeeze(Ai(:, 2, 2, :)) .* squeeze(DdetA(:, k, :))) ./ (detA .^2);
    DAinv(:, k, 1, 2, :) = -(squeeze(DA(:, k, 1, 2, :)) .* detA - squeeze(Ai(:, 1, 2, :)) .* squeeze(DdetA(:, k, :))) ./ (detA .^2);
    DAinv(:, k, 2, 1, :) = -(squeeze(DA(:, k, 2, 1, :)) .* detA - squeeze(Ai(:, 2, 1, :)) .* squeeze(DdetA(:, k, :))) ./ (detA .^2);
    DAinv(:, k, 2, 2, :) = -(squeeze(DA(:, k, 2, 2, :)) .* detA - squeeze(Ai(:, 2, 2, :)) .* squeeze(DdetA(:, k, :))) ./ (detA .^2);
end

% Compute vspharm independent stuff.
T11 = zeros(2, 2, m, nq);
T12 = zeros(2, 2, m, nq);
T21 = zeros(2, 2, m, nq);
T22 = zeros(2, 2, m, nq);
for k=1:2
    for l=1:2
        T11(k, l, :, :) = squeeze(Ai(:, 1, k, :) .* Ai(:, 1, l, :));
        T21(k, l, :, :) = squeeze(Ai(:, 2, k, :) .* Ai(:, 1, l, :));
        T12(k, l, :, :) = squeeze(Ai(:, 1, k, :) .* Ai(:, 2, l, :));
        T22(k, l, :, :) = squeeze(Ai(:, 2, k, :) .* Ai(:, 2, l, :));
    end
end

Z11 = zeros(m, dim, nq);
Z12 = zeros(m, dim, nq);
Z21 = zeros(m, dim, nq);
Z22 = zeros(m, dim, nq);
for k=1:2
    for l=1:2
        %Z(:, d, i, j, :) = squeeze(Z(:, d, i, j, :)) + squeeze(Ai(:, i, k, :)) .* squeeze(Y(:, d, l, :)) .* squeeze(DAinv(:, k, l, j, :));
        T1 = bsxfun(@times, reshape(Y(:, :, l, :), [m, dim, nq]), reshape(DAinv(:, k, l, 1, :), [m, 1, nq])) + bsxfun(@times, reshape(Ainv(:, l, 1, :), [m, 1, nq]), reshape(DY(:, k, :, l, :), [m, dim, nq]));
        T2 = bsxfun(@times, reshape(Y(:, :, l, :), [m, dim, nq]), reshape(DAinv(:, k, l, 2, :), [m, 1, nq])) + bsxfun(@times, reshape(Ainv(:, l, 2, :), [m, 1, nq]), reshape(DY(:, k, :, l, :), [m, dim, nq]));
        Z11 = Z11 + bsxfun(@times, reshape(Ai(:, 1, k, :), [m, 1, nq]), T1);
        Z12 = Z12 + bsxfun(@times, reshape(Ai(:, 1, k, :), [m, 1, nq]), T2);
        Z21 = Z21 + bsxfun(@times, reshape(Ai(:, 2, k, :), [m, 1, nq]), T1);
        Z22 = Z22 + bsxfun(@times, reshape(Ai(:, 2, k, :), [m, 1, nq]), T2);

        % Assemble first part of third term.
        T = bsxfun(@times, reshape(Ainv(:, l, k, :), [m, 1, nq]), reshape(Y(:, :, l, :), [m, dim, nq]));
        for r=1:2
            for p=1:2
                for q=1:2
                    %Z(:, d, i, j, :) = squeeze(Z(:, d, i, j, :)) + squeeze(Ainv(:, l, k, :)) .* squeeze(Y(:, d, l, :)) .* squeeze(Ai(:, j, q, :)) .* squeeze(g(:, q, p, :)) .* squeeze(Ai(:, i, m, :)) .* squeeze(DA(:, m, k, p, :));
                    Tmqp = bsxfun(@times, reshape(DA(:, r, k, p, :), [m, 1, nq]) .* reshape(g(:, q, p, :), [m, 1, nq]), T);
                    % TODO: Check sizes!
                    Z11 = Z11 + bsxfun(@times, reshape(T11(q, r, :, :), [m, 1, nq]), Tmqp);
                    Z12 = Z12 + bsxfun(@times, reshape(T21(q, r, :, :), [m, 1, nq]), Tmqp);
                    Z21 = Z21 + bsxfun(@times, reshape(T12(q, r, :, :), [m, 1, nq]), Tmqp);
                    Z22 = Z22 + bsxfun(@times, reshape(T22(q, r, :, :), [m, 1, nq]), Tmqp);
                end
            end
        end
        % Assemble second part of third term.
        for p=1:2
            for q=1:2
                %Z(:, d, i, j, :) = squeeze(Z(:, d, i, j, :)) + squeeze(Ai(:, j, q, :)) .* squeeze(Ai(:, i, m, :)) .* squeeze(Y(:, d, l, :)) .* squeeze(G(:, p, m, l, :)) .* squeeze(g(:, q, p, :));
                T = bsxfun(@times, reshape(Y(:, :, k, :), [m, dim, nq]), reshape(g(:, q, p, :), [m, 1, nq]) .* reshape(G(:, p, l, k, :), [m, 1, nq]));
                Z11 = Z11 + bsxfun(@times, reshape(T11(q, l, :, :), [m, 1, nq]), T);
                Z12 = Z12 + bsxfun(@times, reshape(T21(q, l, :, :), [m, 1, nq]), T);
                Z21 = Z21 + bsxfun(@times, reshape(T12(q, l, :, :), [m, 1, nq]), T);
                Z22 = Z22 + bsxfun(@times, reshape(T22(q, l, :, :), [m, 1, nq]), T);
            end
        end

    end
end
end